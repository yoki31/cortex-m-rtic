<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Real-Time Interrupt-driven Concurrency</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Введение</a></li><li class="chapter-item expanded "><a href="by-example.html"><strong aria-hidden="true">1.</strong> RTIC в примерах</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="by-example/app.html"><strong aria-hidden="true">1.1.</strong> Атрибут app</a></li><li class="chapter-item expanded "><a href="by-example/resources.html"><strong aria-hidden="true">1.2.</strong> Ресурсы</a></li><li class="chapter-item expanded "><a href="by-example/tasks.html"><strong aria-hidden="true">1.3.</strong> Задачи</a></li><li class="chapter-item expanded "><a href="by-example/timer-queue.html"><strong aria-hidden="true">1.4.</strong> Очередь таймера</a></li><li class="chapter-item expanded "><a href="by-example/singletons.html"><strong aria-hidden="true">1.5.</strong> Одиночки</a></li><li class="chapter-item expanded "><a href="by-example/types-send-sync.html"><strong aria-hidden="true">1.6.</strong> Типы, Send и Sync</a></li><li class="chapter-item expanded "><a href="by-example/new.html"><strong aria-hidden="true">1.7.</strong> Создание нового проекта</a></li><li class="chapter-item expanded "><a href="by-example/tips.html"><strong aria-hidden="true">1.8.</strong> Советы и хитрости</a></li></ol></li><li class="chapter-item expanded "><a href="internals.html"><strong aria-hidden="true">2.</strong> Под капотом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="internals/ceilings.html"><strong aria-hidden="true">2.1.</strong> Ceiling analysis</a></li><li class="chapter-item expanded "><a href="internals/tasks.html"><strong aria-hidden="true">2.2.</strong> Диспетчер задач</a></li><li class="chapter-item expanded "><a href="internals/timer-queue.html"><strong aria-hidden="true">2.3.</strong> Очередь таймера</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Real-Time Interrupt-driven Concurrency</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 align="center">Real-Time Interrupt-driven Concurrency</h1>
<p align="center">Конкурентный фреймворк для создания систем реального времени</p>
<h1 id="Введение"><a class="header" href="#Введение">Введение</a></h1>
<p>Эта книга содержит документацию уровня пользователя фреймворком Real-Time Interrupt-driven Concurrency
(RTIC). Описание API можно найти <a href="../../api/rtic/index.html">здесь</a>.</p>
<h2 id="Возможности"><a class="header" href="#Возможности">Возможности</a></h2>
<ul>
<li>
<p><strong>Задачи</strong> - единица конкуренции <sup class="footnote-reference"><a href="#1">1</a></sup>. Задачи могут <em>запускаться по событию</em>
(в ответ на асинхронный стимул) или вызываться программно по желанию.</p>
</li>
<li>
<p><strong>Передача сообщений</strong> между задачами. А именно, сообщения можно передавать
программным задачам в момент вызова.</p>
</li>
<li>
<p><strong>Очередь таймера</strong> <sup class="footnote-reference"><a href="#2">2</a></sup>. Программные задачи можно планировать на запуск в
определенный момент в будущем. Это свойство можно использовать, чтобы
реализовывать периодические задачи.</p>
</li>
<li>
<p>Поддержка приоритетов задач, и таким образом, <strong>вытесняющей многозадачности</strong>.</p>
</li>
<li>
<p><strong>Эффективное, свободное от гонок данных разделение памяти</strong> через хорошо
разграниченные критические секции на <em>основе приоритетов</em> <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p><strong>Выполнение без взаимной блокировки задач</strong>, гарантированное на этапе
компиляции. Это более сильная гарантия, чем предоставляемая
<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">стандартной абстракцией <code>Mutex</code></a>.</p>
</li>
</ul>
<ul>
<li>
<p><strong>Минимальные затраты на диспетчеризацию</strong>. Диспетчер задач имеет
минимальный след; основная часть работы по диспетчеризации делается аппаратно.</p>
</li>
<li>
<p><strong>Высокоэффективное использование памяти</strong>: Все задачи используют общий стек
вызовов и нет сильной зависимости от динамического распределителя памяти.</p>
</li>
<li>
<p><strong>Все устройства Cortex-M полностью поддерживаются</strong>.</p>
</li>
<li>
<p>Эта модель задач поддается известному анализу методом WCET (наихудшего
времени исполнения) и техникам анализа диспетчеризации. (Хотя мы еще не
разработали для дружественных инструментов для этого).</p>
</li>
</ul>
<h2 id="Требования"><a class="header" href="#Требования">Требования</a></h2>
<ul>
<li>
<p>Rust 1.31.0+</p>
</li>
<li>
<p>Программы нужно писать используя 2018 edition.</p>
</li>
</ul>
<h2 id="Благодарности"><a class="header" href="#Благодарности">Благодарности</a></h2>
<p>Эта библиотека основана на <a href="http://www.rtic-lang.org/">языке RTIC</a>, созданном Embedded
Systems group в <a href="https://www.ltu.se/?l=en">Техническом Университете Luleå</a>, под рук.
<a href="https://www.ltu.se/staff/p/pln-1.11258?l=en">Prof. Per Lindgren</a>.</p>
<h2 id="Ссылки"><a class="header" href="#Ссылки">Ссылки</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Eriksson, J., Häggström, F., Aittamaa, S., Kruglyak, A., &amp; Lindgren, P.
(2013, June). Real-time for the masses, step 1: Programming API and static
priority SRP kernel primitives. In Industrial Embedded Systems (SIES), 2013
8th IEEE International Symposium on (pp. 110-113). IEEE.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Lindgren, P., Fresk, E., Lindner, M., Lindner, A., Pereira, D., &amp; Pinho,
L. M. (2016). Abstract timers and their implementation onto the arm cortex-m
family of mcus. ACM SIGBED Review, 13(1), 48-53.</p>
</div>
<h2 id="Лицензия"><a class="header" href="#Лицензия">Лицензия</a></h2>
<p>Все исходные тексты (включая примеры кода) лицензированы либо под:</p>
<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> или
<a href="https://www.apache.org/licenses/LICENSE-2.0">https://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or
<a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>)</li>
</ul>
<p>на Ваше усмотрение.</p>
<p>Текст книги лицензирован по условиям лицензий
Creative Commons CC-BY-SA v4.0 (<a href="LICENSE-CC-BY-SA">LICENSE-CC-BY-SA</a> или
<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">https://creativecommons.org/licenses/by-sa/4.0/legalcode</a>).</p>
<h3 id="contribution"><a class="header" href="#contribution">Contribution</a></h3>
<p>Если вы явно не заявляете иначе, любой взнос, преднамеренно представленный
для включения в эту работу, как определено в лицензии Apache-2.0, лицензируется, как указано выше, без каких-либо дополнительных условий.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rtic-в-примерах"><a class="header" href="#rtic-в-примерах">RTIC в примерах</a></h1>
<p>Эта часть книги представляет фреймворк Real-Time Interrupt-driven Concurrency (RTIC)
новым пользователям через примеры с растущей сложностью.</p>
<p>Все примеры в этой книге можно найти в <a href="https://github.com/japaric/cortex-m-rtic">репозитории</a> проекта на GitHub,
и большинство примеров можно запустить на эмуляторе QEMU, поэтому никакого
специального оборудования не требуется их выполнять.</p>
<p>Чтобы запустить примеры на Вашем ноутбуке / ПК, Вам нужна программа
<code>qemu-system-arm</code>. Инструкции по настройке окружения для разработки
встраиваемых устройств, в том числе QEMU, Вы можете найти в <a href="https://rust-embedded.github.io/book/intro/install.html">the embedded Rust book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-app-attribute"><a class="header" href="#the-app-attribute">The <code>app</code> attribute</a></h1>
<p>Это наименьшая возможная программа на RTIC:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/smallest.rs

#![no_main]
#![no_std]

use panic_semihosting as _; // panic handler
use rtic::app;

#[app(device = lm3s6965)]
const APP: () = {};
<span class="boring">}
</span></code></pre></pre>
<p>Все программы на RTIC используют атрибут <a href="by-example/../../../api/cortex_m_rtic_macros/attr.app.html"><code>app</code></a> (<code>#[app(..)]</code>). Этот атрибут
нужно применять к <code>const</code>-элементам, содержащим элементы. Атрибут <code>app</code> имеет
обязательный аргумент <code>device</code>, в качестве значения которому передается <em>путь</em>.
Этот путь должен указывать на библиотеку <em>устройства</em>, сгенерированную с помощью
<a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> <strong>v0.14.x</strong>. Атрибут <code>app</code> развернется в удобную точку входа,
поэтому нет необходимости использовать атрибут <a href="by-example/../../../api/cortex_m_rt_macros/attr.entry.html"><code>cortex_m_rt::entry</code></a>.</p>
<blockquote>
<p><strong>ОТСТУПЛЕНИЕ</strong>: Некоторые из вас удивятся, почему мы используем ключевое слово <code>const</code> как
модуль, а не правильное <code>mod</code>. Причина в том, что использование атрибутов на
модулях требует feature gate, который требует ночную сборку. Чтобы заставить
RTIC работать на стабильной сборке, мы используем вместо него слово <code>const</code>.
Когда большая часть макросов 1.2 стабилизируются, мы прейдем от <code>const</code> к <code>mod</code> и в конце концов в атрибуту уровне приложения (<code>#![app]</code>).</p>
</blockquote>
<h2 id="init"><a class="header" href="#init"><code>init</code></a></h2>
<p>Внутри псевдо-модуля атрибут <code>app</code> ожидает найти функцию инициализации, обозначенную
атрибутом <code>init</code>. Эта функция должна иметь сигнатуру <code>[unsafe] fn()</code>.</p>
<p>Эта функция инициализации будет первой частью запускаемого приложения.
Функция <code>init</code> запустится <em>с отключенными прерываниями</em> и будет иметь эксклюзивный
доступ к периферии Cortex-M и специфичной для устройства периферии через переменные
<code>core</code> and <code>device</code>, которые внедряются в область видимости <code>init</code> атрибутом <code>app</code>.
Не вся периферия Cortex-M доступна в <code>core</code>, потому что рантайм RTIC принимает владение
частью из неё -- более подробно см. структуру <a href="by-example/../../api/rtic/struct.Peripherals.html"><code>rtic::Peripherals</code></a>.</p>
<p>Переменные <code>static mut</code>, определённые в начале <code>init</code> будут преобразованы
в ссылки <code>&amp;'static mut</code> с безопасным доступом.</p>
<p>Пример ниже показывает типы переменных <code>core</code> и <code>device</code> и
демонстрирует безопасный доступ к переменной <code>static mut</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/init.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use panic_semihosting as _;

#[rtic::app(device = lm3s6965, peripherals = true)]
const APP: () = {
    #[init]
    fn init(cx: init::Context) {
        static mut X: u32 = 0;

        // Cortex-M peripherals
        let _core: cortex_m::Peripherals = cx.core;

        // Device specific peripherals
        let _device: lm3s6965::Peripherals = cx.device;

        // Safe access to local `static mut` variable
        let _x: &amp;'static mut u32 = X;

        hprintln!(&quot;init&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>Запуск примера напечатает  <code>init</code> в консоли и завершит процесс QEMU.</p>
<pre><code class="language-console">$ cargo run --example init
init```

## `idle`

Функция, помеченная атрибутом `idle` может присутствовать в псевдо-модуле
опционально. Эта функция используется как специальная *задача ожидания* и должна иметь
сигнатуру `[unsafe] fn() - &gt; !`.

Когда она присутствует, рантайм запустит задачу `idle` после `init`. В отличие от
`init`, `idle` запустится *с включенными прерываниями* и не может завершиться,
поэтому будет работать бесконечно.

Когда функция `idle` не определена, рантайм устанавливает бит [SLEEPONEXIT], после чего
отправляет микроконтроллер в состояние сна после выполнения `init`.

[SLEEPONEXIT]: https://developer.arm.com/docs/100737/0100/power-management/sleep-mode/sleep-on-exit-bit

Как и в `init`, переменные `static mut`будут преобразованы в ссылки `&amp;'static mut`
с безопасным доступом.

В примере ниже показан запуск `idle` после `init`.

``` rust
//! examples/idle.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        hprintln!(&quot;init&quot;).unwrap();
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        static mut X: u32 = 0;

        // Safe access to local `static mut` variable
        let _x: &amp;'static mut u32 = X;

        hprintln!(&quot;idle&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);

        loop {}
    }
};
</code></pre>
<pre><code class="language-console">$ cargo run --example idle
init
idle```

## `interrupt` / `exception`

Как Вы бы сделали с помощью библиотеки `cortex-m-rt`, Вы можете использовать атрибуты
`interrupt` и `exception` внутри псевдо-модуля `app`, чтобы определить обработчики
прерываний и исключений. В RTIC, мы называем обработчики прерываний и исключений
*аппаратными* задачами.

``` rust
{{#include ../../../../examples/interrupt.rs}}
</code></pre>
<pre><code class="language-console">$ cargo run --example interrupt
{{#include ../../../../ci/expected/interrupt.run}}```

До сих пор программы RTIC, которые мы видели не отличались от программ, которые
можно написать, используя только библиотеку `cortex-m-rt`. В следующем разделе
мы начнем знакомиться с функционалом, присущим только RTIC.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Ресурсы"><a class="header" href="#Ресурсы">Ресурсы</a></h2>
<p>Одно из ограничений атрибутов, предоставляемых библиотекой <code>cortex-m-rt</code> является
то, что совместное использование данных (или периферии) между прерываниями,
или прерыванием и функцией <code>init</code>, требуют <code>cortex_m::interrupt::Mutex</code>, который
<em>всегда</em> требует отключения <em>всех</em> прерываний для доступа к данным. Отключение всех
прерываний не всегда необходимо для безопасности памяти, но компилятор не имеет
достаточно информации, чтобы оптимизировать доступ к разделяемым данным.</p>
<p>Атрибут <code>app</code> имеет полную картину приложения, поэтому может оптимизировать доступ к
<code>static</code>-переменным. В RTIC мы обращаемся к <code>static</code>-переменным, объявленным внутри
псевдо-модуля <code>app</code> как к <em>ресурсам</em>. Чтобы получить доступ к ресурсу, контекст
(<code>init</code>, <code>idle</code>, <code>interrupt</code> или <code>exception</code>) должен сначала определить
аргумент <code>resources</code> в соответствующем атрибуте.</p>
<p>В примере ниже два обработчика прерываний имеют доступ к одному и тому же ресурсу.
Никакого <code>Mutex</code> в этом случае не требуется, потому что оба обработчика запускаются
с одним приоритетом и никакого вытеснения быть не может.
К ресурсу <code>SHARED</code> можно получить доступ только из этих двух прерываний.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/resource.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;
use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
const APP: () = {
    struct Resources {
        // A resource
        #[init(0)]
        shared: u32,
    }

    #[init]
    fn init(_: init::Context) {
        rtic::pend(Interrupt::UART0);
        rtic::pend(Interrupt::UART1);
    }

    // `shared` cannot be accessed from this context
    #[idle]
    fn idle(_cx: idle::Context) -&gt; ! {
        debug::exit(debug::EXIT_SUCCESS);

        // error: no `resources` field in `idle::Context`
        // _cx.resources.shared += 1;

        loop {}
    }

    // `shared` can be accessed from this context
    #[task(binds = UART0, resources = [shared])]
    fn uart0(cx: uart0::Context) {
        let shared: &amp;mut u32 = cx.resources.shared;
        *shared += 1;

        hprintln!(&quot;UART0: shared = {}&quot;, shared).unwrap();
    }

    // `shared` can be accessed from this context
    #[task(binds = UART1, resources = [shared])]
    fn uart1(cx: uart1::Context) {
        *cx.resources.shared += 1;

        hprintln!(&quot;UART1: shared = {}&quot;, cx.resources.shared).unwrap();
    }
};
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example resource
UART0: shared = 1
UART1: shared = 2
</code></pre>
<h2 id="Приоритеты"><a class="header" href="#Приоритеты">Приоритеты</a></h2>
<p>Приоритет каждого прерывания можно определить в атрибутах <code>interrupt</code> и <code>exception</code>.
Невозможно установить приоритет любым другим способом, потому что рантайм
забирает владение прерыванием <code>NVIC</code>; также невозможно изменить приоритет
обработчика / задачи в рантайме. Благодаря этому ограничению у фреймворка
есть знание о <em>статических</em> приоритетах всех обработчиков прерываний и исключений.</p>
<p>Прерывания и исключения могут иметь приоритеты в интервале <code>1..=(1 &lt;&lt; NVIC_PRIO_BITS)</code>,
где <code>NVIC_PRIO_BITS</code> - константа, определённая в библиотеке <code>device</code>.
Задача <code>idle</code> имеет приоритет <code>0</code>, наименьший.</p>
<p>Ресурсы, совместно используемые обработчиками, работающими на разных приоритетах,
требуют критических секций для безопасности памяти. Фреймворк проверяет, что
критические секции используются, но <em>только где необходимы</em>: например,
критические секции не нужны для обработчика с наивысшим приоритетом, имеющим
доступ к ресурсу.</p>
<p>API критической секции, предоставляемое фреймворком RTIC (см. <a href="by-example/../../../api/rtic/trait.Mutex.html"><code>Mutex</code></a>),
основано на динамических приоритетах вместо отключения прерываний. Из этого следует,
что критические секции не будут допускать <em>запуск некоторых</em> обработчиков,
включая все соперничающие за ресурс, но будут позволять запуск обработчиков с
большим приоритетом не соперничащих за ресурс.</p>
<p>В примере ниже у нас есть 3 обработчика прерываний с приоритетами от одного
до трех. Два обработчика с низким приоритетом соперничают за ресурс <code>SHARED</code>.
Обработчик с низшим приоритетом должен заблокировать (<a href="by-example/../../../api/rtic/trait.Mutex.html#method.lock"><code>lock</code></a>) ресурс
<code>SHARED</code>, чтобы получить доступ к его данным, в то время как обработчик со
средним приоритетом может напрямую получать доступ к его данным. Обработчик
с наивысшим приоритетом может свободно вытеснять критическую секцию,
созданную обработчиком с низшим приоритетом.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/lock.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;
use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
const APP: () = {
    struct Resources {
        #[init(0)]
        shared: u32,
    }

    #[init]
    fn init(_: init::Context) {
        rtic::pend(Interrupt::GPIOA);
    }

    // when omitted priority is assumed to be `1`
    #[task(binds = GPIOA, resources = [shared])]
    fn gpioa(mut c: gpioa::Context) {
        hprintln!(&quot;A&quot;).unwrap();

        // the lower priority task requires a critical section to access the data
        c.resources.shared.lock(|shared| {
            // data can only be modified within this critical section (closure)
            *shared += 1;

            // GPIOB will *not* run right now due to the critical section
            rtic::pend(Interrupt::GPIOB);

            hprintln!(&quot;B - shared = {}&quot;, *shared).unwrap();

            // GPIOC does not contend for `shared` so it's allowed to run now
            rtic::pend(Interrupt::GPIOC);
        });

        // critical section is over: GPIOB can now start

        hprintln!(&quot;E&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(binds = GPIOB, priority = 2, resources = [shared])]
    fn gpiob(c: gpiob::Context) {
        // the higher priority task does *not* need a critical section
        *c.resources.shared += 1;

        hprintln!(&quot;D - shared = {}&quot;, *c.resources.shared).unwrap();
    }

    #[task(binds = GPIOC, priority = 3)]
    fn gpioc(_: gpioc::Context) {
        hprintln!(&quot;C&quot;).unwrap();
    }
};
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example lock
A
B - shared = 1
C
D - shared = 2
E```

## Поздние ресурсы

В отличие от обычных `static`-переменных, к которым должно быть присвоено
начальное значение, ресурсы можно инициализировать в рантайме.
Мы называем ресурсы, инициализируемые в рантайме *поздними*. Поздние ресурсы
полезны для *переноса* (как при передаче владения) периферии из `init` в
обработчики прерываний и исключений.

Поздние ресурсы определяются как обычные ресурсы, но им присваивается начальное
значение `()` (the unit value). `init` должен вернуть начальные значения для
всех поздних ресурсов, упакованные в структуру типа `init::LateResources`.

В примере ниже использованы поздние ресурсы, чтобы установить неблокированный,
односторонний канал между обработчиком прерывания `UART0` и функцией `idle`.
Очередь типа один производитель-один потребитель [`Queue`] использована как канал.
Очередь разделена на элементы потребителя и поизводителя в `init` и каждый элемент
расположен в отдельном ресурсе; `UART0` владеет ресурсом произодителя, а `idle`
владеет ресурсом потребителя.

[`Queue`]: ../../../api/heapless/spsc/struct.Queue.html

``` rust
//! examples/late.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use heapless::{
    consts::*,
    i,
    spsc::{Consumer, Producer, Queue},
};
use lm3s6965::Interrupt;
use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
const APP: () = {
    // Late resources
    struct Resources {
        p: Producer&lt;'static, u32, U4&gt;,
        c: Consumer&lt;'static, u32, U4&gt;,
    }

    #[init]
    fn init(_: init::Context) -&gt; init::LateResources {
        static mut Q: Queue&lt;u32, U4&gt; = Queue(i::Queue::new());

        let (p, c) = Q.split();

        // Initialization of late resources
        init::LateResources { p, c }
    }

    #[idle(resources = [c])]
    fn idle(c: idle::Context) -&gt; ! {
        loop {
            if let Some(byte) = c.resources.c.dequeue() {
                hprintln!(&quot;received message: {}&quot;, byte).unwrap();

                debug::exit(debug::EXIT_SUCCESS);
            } else {
                rtic::pend(Interrupt::UART0);
            }
        }
    }

    #[task(binds = UART0, resources = [p])]
    fn uart0(c: uart0::Context) {
        c.resources.p.enqueue(42).unwrap();
    }
};
</code></pre>
<pre><code class="language-console">$ cargo run --example late
received message: 42```

## `static`-ресурсы

Переменные типа `static` также можно использовать в качестве ресурсов. Задачи
могут получать только (разделяемые) `&amp;` ссылки на ресурсы, но блокировки не
нужны для доступа к данным. Вы можете думать о `static`-ресурсах как о простых
`static`-переменных, которые можно инициализировать в рантайме и иметь лучшие
правила видимости: Вы можете контролировать, какие задачи получают доступ к
переменной, чтобы переменная не была видна всем фунциям в область видимости,
где она была объявлена.

В примере ниже ключ загружен (или создан) в рантайме, а затем использован в двух
задачах, запущенных на разных приоритетах.

``` rust
{{#include ../../../../examples/static.rs}}
</code></pre>
<pre><code class="language-console">$ cargo run --example static
{{#include ../../../../ci/expected/static.run}}```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Программные-задачи"><a class="header" href="#Программные-задачи">Программные задачи</a></h1>
<p>RTIC обрабатывает прерывания и исключения как <em>аппаратные</em> задачи. Аппаратные
задачи могут вызываться устройством в ответ на события, такие как нажатие кнопки.
RTIC также поддерживает <em>программные</em> задачи, порождаемые программой из любого
контекста выполнения.</p>
<p>Программным задачам также можно назначать приоритет и диспетчеризовать из
обработчиков прерываний. RTIC требует определения свободных прерываний в блоке
<code>extern</code>, когда используются программные задачи; эти свободные прерывания будут использованы, чтобы диспетчеризовать программные задачи. Преимущество программных
задач перед аппаратными в том, что  на один обработчик прерывания можно назначить
множество задач.</p>
<p>Программные задачи определяются заданием функциям атрибута <code>task</code>. Чтобы было
возможно вызывать программные задачи, имя задачи нужно передать в аргументе
<code>spawn</code> контекста атрибута (<code>init</code>, <code>idle</code>, <code>interrupt</code>, etc.).</p>
<p>В примере ниже продемонстрированы три программных задачи, запускаемые на 2-х
разных приоритетах. Трем задачам назначены 2 обработчика прерываний.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/task.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [foo])]
    fn init(c: init::Context) {
        c.spawn.foo().unwrap();
    }

    #[task(spawn = [bar, baz])]
    fn foo(c: foo::Context) {
        hprintln!(&quot;foo - start&quot;).unwrap();

        // spawns `bar` onto the task scheduler
        // `foo` and `bar` have the same priority so `bar` will not run until
        // after `foo` terminates
        c.spawn.bar().unwrap();

        hprintln!(&quot;foo - middle&quot;).unwrap();

        // spawns `baz` onto the task scheduler
        // `baz` has higher priority than `foo` so it immediately preempts `foo`
        c.spawn.baz().unwrap();

        hprintln!(&quot;foo - end&quot;).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(priority = 2)]
    fn baz(_: baz::Context) {
        hprintln!(&quot;baz&quot;).unwrap();
    }

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
        fn QEI0();
    }
};
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example task
foo - start
foo - middle
baz
foo - end
bar```

## Передача сообщений

Другое преимущество программных задач - возможность передавать сообщения задачам
во время их вызова. Тип полезной нагрузки сообщения должен быть определен в
сигнатуре обработчика задачи.

Пример ниже демонстрирует три задачи, две из которых ожидают сообщения.

``` rust
//! examples/message.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [foo])]
    fn init(c: init::Context) {
        c.spawn.foo(/* no message */).unwrap();
    }

    #[task(spawn = [bar])]
    fn foo(c: foo::Context) {
        static mut COUNT: u32 = 0;

        hprintln!(&quot;foo&quot;).unwrap();

        c.spawn.bar(*COUNT).unwrap();
        *COUNT += 1;
    }

    #[task(spawn = [baz])]
    fn bar(c: bar::Context, x: u32) {
        hprintln!(&quot;bar({})&quot;, x).unwrap();

        c.spawn.baz(x + 1, x + 2).unwrap();
    }

    #[task(spawn = [foo])]
    fn baz(c: baz::Context, x: u32, y: u32) {
        hprintln!(&quot;baz({}, {})&quot;, x, y).unwrap();

        if x + y &gt; 4 {
            debug::exit(debug::EXIT_SUCCESS);
        }

        c.spawn.foo().unwrap();
    }

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
    }
};
</code></pre>
<pre><code class="language-console">$ cargo run --example message
foo
bar(0)
baz(1, 2)
foo
bar(1)
baz(2, 3)```

## Ёмкость

Диспетчеры задач *не* используют динамическое выделение памяти. Память
необходимая для размещения сообщений, резервируется статически. Фреймворк
зарезервирует достаточно памяти для каждого контекста, чтобы можно было вызвать
каждую задачу как минимум единожды. Это разумно по умолчанию, но
&quot;внутреннюю&quot; ёмкость каждой задачи можно контролировать используя аргумент
`capacity` атрибута `task`.

В примере ниже установлена ёмкость программной задачи `foo` на 4. Если ёмкость
не определена, тогда второй вызов `spawn.foo` в `UART0` вызовет ошибку.

``` rust
//! examples/capacity.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;
use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        rtic::pend(Interrupt::UART0);
    }

    #[task(binds = UART0, spawn = [foo, bar])]
    fn uart0(c: uart0::Context) {
        c.spawn.foo(0).unwrap();
        c.spawn.foo(1).unwrap();
        c.spawn.foo(2).unwrap();
        c.spawn.foo(3).unwrap();

        c.spawn.bar().unwrap();
    }

    #[task(capacity = 4)]
    fn foo(_: foo::Context, x: u32) {
        hprintln!(&quot;foo({})&quot;, x).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
    }
};
</code></pre>
<pre><code class="language-console">$ cargo run --example capacity
foo(0)
foo(1)
foo(2)
foo(3)
bar```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Очередь-таймера"><a class="header" href="#Очередь-таймера">Очередь таймера</a></h1>
<p>Когда включена опция <code>timer-queue</code>, фреймворк RTIC включает
<em>глобальную очередь таймера</em>, которую приложения могут использовать, чтобы
<em>планировать</em> программные задачи на запуск через некоторое время в будущем.</p>
<p>Чтобы была возможность планировать программную задачу, имя задачи должно
присутствовать в аргументе <code>schedule</code> контекста атрибута. Когда задача
планируется, момент (<a href="by-example/../../../api/rtic/struct.Instant.html"><code>Instant</code></a>), в который задачу нужно запустить, нужно передать
как первый аргумент вызова <code>schedule</code>.</p>
<p>Рантайм RTIC включает монотонный, растущий только вверх, 32-битный таймер,
значение которого можно запросить конструктором <code>Instant::now</code>. Время (<a href="by-example/../../../api/rtic/struct.Duration.html"><code>Duration</code></a>)
можно передать в <code>Instant::now()</code>, чтобы получить <code>Instant</code> в будущем. Монотонный
таймер отключен пока запущен <code>init</code>, поэтому <code>Instant::now()</code> всегда возвращает
значение <code>Instant(0 /* циклов тактовой частоты */)</code>; таймер включается сразу перед
включением прерываний и запуском <code>idle</code>.</p>
<p>В примере ниже две задачи планируются из <code>init</code>: <code>foo</code> и <code>bar</code>. <code>foo</code> -
запланирована на запуск через 8 миллионов тактов в будущем. Кроме того, <code>bar</code>
запланирован на запуск через 4 миллиона тактов в будущем. <code>bar</code> запустится раньше
<code>foo</code>, т.к. он запланирован на запуск первым.</p>
<blockquote>
<p><strong>ВАЖНО</strong>: Примеры, использующие API <code>schedule</code> или абстракцию <code>Instant</code>
<strong>не</strong> будут правильно работать на QEMU, потому что функциональность счетчика
тактов Cortex-M не реализована в <code>qemu-system-arm</code>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/schedule.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m::peripheral::DWT;
use cortex_m_semihosting::hprintln;
use panic_semihosting as _;
use rtic::cyccnt::{Instant, U32Ext as _};

// NOTE: does NOT work on QEMU!
#[rtic::app(device = lm3s6965, monotonic = rtic::cyccnt::CYCCNT)]
const APP: () = {
    #[init(schedule = [foo, bar])]
    fn init(mut cx: init::Context) {
        // Initialize (enable) the monotonic timer (CYCCNT)
        cx.core.DCB.enable_trace();
        // required on Cortex-M7 devices that software lock the DWT (e.g. STM32F7)
        DWT::unlock();
        cx.core.DWT.enable_cycle_counter();

        // semantically, the monotonic timer is frozen at time &quot;zero&quot; during `init`
        // NOTE do *not* call `Instant::now` in this context; it will return a nonsense value
        let now = cx.start; // the start time of the system

        hprintln!(&quot;init @ {:?}&quot;, now).unwrap();

        // Schedule `foo` to run 8e6 cycles (clock cycles) in the future
        cx.schedule.foo(now + 8_000_000.cycles()).unwrap();

        // Schedule `bar` to run 4e6 cycles in the future
        cx.schedule.bar(now + 4_000_000.cycles()).unwrap();
    }

    #[task]
    fn foo(_: foo::Context) {
        hprintln!(&quot;foo  @ {:?}&quot;, Instant::now()).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar  @ {:?}&quot;, Instant::now()).unwrap();
    }

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>Запуск программы на реальном оборудовании производит следующий вывод в консоли:</p>
<pre><code class="language-text">init @ Instant(0)
bar  @ Instant(4000236)
foo  @ Instant(8000173)
</code></pre>
<h2 id="Периодические-задачи"><a class="header" href="#Периодические-задачи">Периодические задачи</a></h2>
<p>Программные задачи имеют доступ к <code>Instant</code> в момент, когда были запланированы
на запуск через переменную <code>scheduled</code>. Эта информация и API <code>schedule</code> могут
быть использованы для реализации периодических задач, как показано в примере ниже.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/periodic.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::hprintln;
use panic_semihosting as _;
use rtic::cyccnt::{Instant, U32Ext};

const PERIOD: u32 = 8_000_000;

// NOTE: does NOT work on QEMU!
#[rtic::app(device = lm3s6965, monotonic = rtic::cyccnt::CYCCNT)]
const APP: () = {
    #[init(schedule = [foo])]
    fn init(cx: init::Context) {
        // omitted: initialization of `CYCCNT`

        cx.schedule.foo(cx.start + PERIOD.cycles()).unwrap();
    }

    #[task(schedule = [foo])]
    fn foo(cx: foo::Context) {
        let now = Instant::now();
        hprintln!(&quot;foo(scheduled = {:?}, now = {:?})&quot;, cx.scheduled, now).unwrap();

        cx.schedule.foo(cx.scheduled + PERIOD.cycles()).unwrap();
    }

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>Это вывод, произведенный примером. Заметьте, что есть смещение / колебание нуля
даже если <code>schedule.foo</code> была вызвана в <em>конце</em> <code>foo</code>. Использование
<code>Instant::now</code> вместо <code>scheduled</code> имело бы влияние на смещение / колебание.</p>
<pre><code class="language-text">foo(scheduled = Instant(8000000), now = Instant(8000196))
foo(scheduled = Instant(16000000), now = Instant(16000196))
foo(scheduled = Instant(24000000), now = Instant(24000196))
</code></pre>
<h2 id="Базовое-время"><a class="header" href="#Базовое-время">Базовое время</a></h2>
<p>Для задач, планируемых из <code>init</code> мы имеем точную информацию о их планируемом
(<code>scheduled</code>) времени. Для аппаратных задач нет <code>scheduled</code> времени, потому
что эти задачи асинхронны по природе. Для аппаратных задач рантайм предоставляет
время старта (<code>start</code>), которе отражает время, в которое обработчик прерывания
был запущен.</p>
<p>Заметьте, что <code>start</code> <strong>не</strong> равен времени возникновения события, вызвавшего
задачу. В зависимости от приоритета задачи и загрузки системы время
<code>start</code> может быть сильно отдалено от времени возникновения события.</p>
<p>Какое по Вашему мнению будет значение <code>scheduled</code> для программных задач которые
<em>вызываются</em>, вместо того чтобы планироваться? Ответ в том, что вызываемые
задачи наследуют <em>базовое</em> время контекста, в котором вызваны. Бызовым для
аппаратных задач является <code>start</code>, базовым для программных задач - <code>scheduled</code>
и базовым для <code>init</code> - <code>start = Instant(0)</code>. <code>idle</code> на сомом деле не имеет
базового времени но задачи, вызванные из него будут использовать <code>Instant::now()</code>
как их базовое время.</p>
<p>Пример ниже демонстрирует разное значение <em>базового времени</em>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/baseline.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;
use panic_semihosting as _;

// NOTE: does NOT properly work on QEMU
#[rtic::app(device = lm3s6965, monotonic = rtic::cyccnt::CYCCNT)]
const APP: () = {
    #[init(spawn = [foo])]
    fn init(cx: init::Context) {
        // omitted: initialization of `CYCCNT`

        hprintln!(&quot;init(baseline = {:?})&quot;, cx.start).unwrap();

        // `foo` inherits the baseline of `init`: `Instant(0)`
        cx.spawn.foo().unwrap();
    }

    #[task(schedule = [foo])]
    fn foo(cx: foo::Context) {
        static mut ONCE: bool = true;

        hprintln!(&quot;foo(baseline = {:?})&quot;, cx.scheduled).unwrap();

        if *ONCE {
            *ONCE = false;

            rtic::pend(Interrupt::UART0);
        } else {
            debug::exit(debug::EXIT_SUCCESS);
        }
    }

    #[task(binds = UART0, spawn = [foo])]
    fn uart0(cx: uart0::Context) {
        hprintln!(&quot;UART0(baseline = {:?})&quot;, cx.start).unwrap();

        // `foo` inherits the baseline of `UART0`: its `start` time
        cx.spawn.foo().unwrap();
    }

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>Запуск программы на реальном оборудовании произведет следующий вывод в консоли:</p>
<pre><code class="language-text">init(baseline = Instant(0))
foo(baseline = Instant(0))
UART0(baseline = Instant(904))
foo(baseline = Instant(904))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Одиночки"><a class="header" href="#Одиночки">Одиночки</a></h1>
<p>Атрибут <code>app</code> знает о библиотеке <a href="by-example/../../api/owned_singleton/index.html"><code>owned-singleton</code></a> и её атрибуте <a href="by-example/../../api/owned_singleton_macros/attr.Singleton.html"><code>Singleton</code></a>.
Когда этот атрибут применяется к одному из ресурсов, рантайм производит для Вас
<code>unsafe</code> инициализацию одиночки, проверяя, что только один экземпляр одиночки
когда-либо создан.</p>
<p>Заметьте, что когда Вы используете атрибут <code>Singleton</code>, Вым нужно иметь
<code>owned_singleton</code> в зависимостях.</p>
<p>В примере ниже атрибутом <code>Singleton</code> аннотирован массив памяти,
а экземпляр одиночки использован как фиксированный по размеру пул памяти
с помощью одной из абстракций <a href="https://crates.io/crates/alloc-singleton"><code>alloc-singleton</code></a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#include ../../../../examples/singleton.rs}}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example singleton
bar(2)
foo(1)```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Типы-send-и-sync"><a class="header" href="#Типы-send-и-sync">Типы, Send и Sync</a></h1>
<p>Атрибут <code>app</code> вводит контекст, коллекцию переменных в каждую из функций.
Все эти переменные имеют предсказуемые, неанонимные типы, поэтому Вы можете
писать простые функции, получающие их как аргументы.</p>
<p>Описание API определяет как эти типы эти типы генерируются из входных данных.
Вы можете также сгенерировать документацию для Вашей бинарной библиотеки
(<code>cargo doc --bin &lt;name&gt;</code>); в документации Вы найдете структуры <code>Context</code>
(например <code>init::Context</code> и <code>idle::Context</code>), чьи поля представляют переменные
включенные в каждую функцию.</p>
<p>В примере ниже сгенерированы разные типы с помощью атрибута <code>app</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/types.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::debug;
use panic_semihosting as _;
use rtic::cyccnt;

#[rtic::app(device = lm3s6965, peripherals = true, monotonic = rtic::cyccnt::CYCCNT)]
const APP: () = {
    struct Resources {
        #[init(0)]
        shared: u32,
    }

    #[init(schedule = [foo], spawn = [foo])]
    fn init(cx: init::Context) {
        let _: cyccnt::Instant = cx.start;
        let _: rtic::Peripherals = cx.core;
        let _: lm3s6965::Peripherals = cx.device;
        let _: init::Schedule = cx.schedule;
        let _: init::Spawn = cx.spawn;

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[idle(schedule = [foo], spawn = [foo])]
    fn idle(cx: idle::Context) -&gt; ! {
        let _: idle::Schedule = cx.schedule;
        let _: idle::Spawn = cx.spawn;

        loop {}
    }

    #[task(binds = UART0, resources = [shared], schedule = [foo], spawn = [foo])]
    fn uart0(cx: uart0::Context) {
        let _: cyccnt::Instant = cx.start;
        let _: resources::shared = cx.resources.shared;
        let _: uart0::Schedule = cx.schedule;
        let _: uart0::Spawn = cx.spawn;
    }

    #[task(priority = 2, resources = [shared], schedule = [foo], spawn = [foo])]
    fn foo(cx: foo::Context) {
        let _: cyccnt::Instant = cx.scheduled;
        let _: &amp;mut u32 = cx.resources.shared;
        let _: foo::Resources = cx.resources;
        let _: foo::Schedule = cx.schedule;
        let _: foo::Spawn = cx.spawn;
    }

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
    }
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="send"><a class="header" href="#send"><code>Send</code></a></h2>
<p><a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a> - маркерный типаж (trait) для &quot;типов, которые можно передавать через границы
потоков&quot;, как это определено в <code>core</code>. В контексте RTIC типаж <code>Send</code> необходим
только там, где возможна передача значения между задачами, запускаемыми на
<em>разных</em> приоритетах. Это возникает в нескольких случаях: при передаче сообщений,
в совместно используемых <code>static mut</code> ресурсах и инициализации поздних ресурсов.</p>
<p>Атрибут <code>app</code> проверит, что <code>Send</code> реализован, где необходимо, поэтому Вам не
стоит волноваться об этом. Более важно знать, где Вам <em>не</em> нужен типаж <code>Send</code>:
в типах, передаваемых между задачами с <em>одинаковым</em> приоритетом. Это возникает
в двух случаях: при передаче сообщений и в совместно используемых <code>static mut</code>
ресурсах.</p>
<p>В примере ниже показано, где можно использовать типы, не реализующие <code>Send</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! `examples/not-send.rs`

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use core::marker::PhantomData;

use cortex_m_semihosting::debug;
use panic_semihosting as _;
use rtic::app;

pub struct NotSend {
    _0: PhantomData&lt;*const ()&gt;,
}

#[app(device = lm3s6965)]
const APP: () = {
    struct Resources {
        #[init(None)]
        shared: Option&lt;NotSend&gt;,
    }

    #[init(spawn = [baz, quux])]
    fn init(c: init::Context) {
        c.spawn.baz().unwrap();
        c.spawn.quux().unwrap();
    }

    #[task(spawn = [bar])]
    fn foo(c: foo::Context) {
        // scenario 1: message passed to task that runs at the same priority
        c.spawn.bar(NotSend { _0: PhantomData }).ok();
    }

    #[task]
    fn bar(_: bar::Context, _x: NotSend) {
        // scenario 1
    }

    #[task(priority = 2, resources = [shared])]
    fn baz(c: baz::Context) {
        // scenario 2: resource shared between tasks that run at the same priority
        *c.resources.shared = Some(NotSend { _0: PhantomData });
    }

    #[task(priority = 2, resources = [shared])]
    fn quux(c: quux::Context) {
        // scenario 2
        let _not_send = c.resources.shared.take().unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
        fn QEI0();
    }
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h2>
<p>Похожая ситуация, <a href="https://doc.rust-lang.org/core/marker/trait.Sync.html"><code>Sync</code></a> -  маркерный типаж для &quot;типов, на которых можно
ссылаться в разных потоках&quot;, как это определено в <code>core</code>. В контексте RTIC
типаж <code>Sync</code> необходим только там, где возможны две или более задачи,
запускаемые на разных приоритетах, чтобы захватить разделяемую ссылку на
ресурс. Это возникает только  совместно используемых <code>static</code>-ресурсах.</p>
<p>Атрибут <code>app</code> проверит, что <code>Sync</code> реализован, где необходимо, но важно знать,
где ограничение <code>Sync</code> не требуется: в <code>static</code>-ресурсах, разделяемых между
задачами с <em>одинаковым</em> приоритетом.</p>
<p>В примере ниже показано, где можно использовать типы, не реализующие <code>Sync</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! `examples/not-sync.rs`

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use core::marker::PhantomData;

use cortex_m_semihosting::debug;
use panic_semihosting as _;

pub struct NotSync {
    _0: PhantomData&lt;*const ()&gt;,
}

#[rtic::app(device = lm3s6965)]
const APP: () = {
    struct Resources {
        #[init(NotSync { _0: PhantomData })]
        shared: NotSync,
    }

    #[init]
    fn init(_: init::Context) {
        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(resources = [&amp;shared])]
    fn foo(c: foo::Context) {
        let _: &amp;NotSync = c.resources.shared;
    }

    #[task(resources = [&amp;shared])]
    fn bar(c: bar::Context) {
        let _: &amp;NotSync = c.resources.shared;
    }

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
    }
};
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Создание-нового-проекта"><a class="header" href="#Создание-нового-проекта">Создание нового проекта</a></h1>
<p>Теперь, когда Вы изучили основные возможности фреймворка RTIC, Вы можете
попробовать его использовать на Вашем оборудовании следуя этим инструкциям.</p>
<ol>
<li>Создайте экземпляр из шаблона <a href="https://github.com/rust-embedded/cortex-m-quickstart#cortex-m-quickstart"><code>cortex-m-quickstart</code></a>.</li>
</ol>
<pre><code class="language-console">$ # например используя `cargo-generate`
$ cargo generate \
    --git https://github.com/rust-embedded/cortex-m-quickstart \
    --name app

$ # следуйте остальным инструкциям
</code></pre>
<ol start="2">
<li>Добавьте крейт устройства, сгенерированный с помощью <a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> <strong>v0.14.x</strong>,
или библиотеку отладочной платы, у которой в зависимостях одно из устройств.
Убедитесь, что опция <code>rt</code> крейта включена.</li>
</ol>
<p>В этом примере я покажу использование крейта устройства <a href="https://crates.io/crates/lm3s6965"><code>lm3s6965</code></a>.
Эта библиотека не имеет Cargo-опции <code>rt</code>; эта опция всегда включена.</p>
<p>Этот крейт устройства предоставляет линковочный скрипт с макетом памяти
целевого устройства, поэтому <code>memory.x</code> и <code>build.rs</code> не нужно удалять.</p>
<pre><code class="language-console">$ cargo add lm3s6965 --vers 0.1.3

$ rm memory.x build.rs
</code></pre>
<ol start="3">
<li>Добавьте библиотеку <code>cortex-m-rtic</code> как зависимость, и если необходимо,
включите опцию <code>timer-queue</code>.</li>
</ol>
<pre><code class="language-console">$ cargo add cortex-m-rtic --allow-prerelease --upgrade=none
</code></pre>
<ol start="4">
<li>Напишите программу RTIC.</li>
</ol>
<p>Здесь я буду использовать пример <code>init</code> из библиотеки <code>cortex-m-rtic</code>.</p>
<pre><code class="language-console">$ curl \
    -L https://github.com/japaric/cortex-m-rtic/raw/v0.4.0-beta.1/examples/init.rs \
    &gt; src/main.rs
</code></pre>
<p>Этот пример зависит от библиотеки <code>panic-semihosting</code>:</p>
<pre><code class="language-console">$ cargo add panic-semihosting
</code></pre>
<ol start="5">
<li>Соберите его, загрузите в микроконтроллер и запустите.</li>
</ol>
<pre><code class="language-console">$ # ПРИМЕЧАНИЕ: Я раскомментировал опцию `runner` в `.cargo/config`
$ cargo run
init```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Советы-и-хитрости"><a class="header" href="#Советы-и-хитрости">Советы и хитрости</a></h1>
<h2 id="Обобщенное-программирование-generics"><a class="header" href="#Обобщенное-программирование-generics">Обобщенное программирование (Generics)</a></h2>
<p>Ресурсы, совместно используемые двумя или более задачами, реализуют трейт <code>Mutex</code>
во <em>всех</em> контекстах, даже в тех, где для доступа к данным не требуются
критические секции. Это позволяет легко писать обобщенный код оперирующий
ресурсами, который можно вызывать из различных задач. Вот такой пример:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/generics.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;
use panic_semihosting as _;
use rtic::{Exclusive, Mutex};

#[rtic::app(device = lm3s6965)]
const APP: () = {
    struct Resources {
        #[init(0)]
        shared: u32,
    }

    #[init]
    fn init(_: init::Context) {
        rtic::pend(Interrupt::UART0);
        rtic::pend(Interrupt::UART1);
    }

    #[task(binds = UART0, resources = [shared])]
    fn uart0(c: uart0::Context) {
        static mut STATE: u32 = 0;

        hprintln!(&quot;UART0(STATE = {})&quot;, *STATE).unwrap();

        // second argument has type `resources::shared`
        advance(STATE, c.resources.shared);

        rtic::pend(Interrupt::UART1);

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(binds = UART1, priority = 2, resources = [shared])]
    fn uart1(c: uart1::Context) {
        static mut STATE: u32 = 0;

        hprintln!(&quot;UART1(STATE = {})&quot;, *STATE).unwrap();

        // just to show that `shared` can be accessed directly
        *c.resources.shared += 0;

        // second argument has type `Exclusive&lt;u32&gt;`
        advance(STATE, Exclusive(c.resources.shared));
    }
};

// the second parameter is generic: it can be any type that implements the `Mutex` trait
fn advance(state: &amp;mut u32, mut shared: impl Mutex&lt;T = u32&gt;) {
    *state += 1;

    let (old, new) = shared.lock(|shared: &amp;mut u32| {
        let old = *shared;
        *shared += *state;
        (old, *shared)
    });

    hprintln!(&quot;shared: {} -&gt; {}&quot;, old, new).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example generics
UART1(STATE = 0)
shared: 0 -&gt; 1
UART0(STATE = 0)
shared: 1 -&gt; 2
UART1(STATE = 1)
shared: 2 -&gt; 4```

Это также позволяет Вам изменять статические приоритеты задач без
переписывания кода. Если Вы единообразно используете `lock`-и для доступа
к данным в разделяемых ресурсах, тогда Ваш код продолжит компилироваться,
когда Вы измените приоритет задач.

## Запуск задач из ОЗУ

Главной целью переноса описания программы на RTIC в атрибуты в
RTIC v0.4.x была возможность взаимодействия с другими атрибутами.
Напримерe, атрибут `link_section` можно применять к задачам, чтобы разместить
их в ОЗУ; это может улучшить производительность в некоторых случаях.

&gt; **ВАЖНО**: Обычно атрибуты `link_section`, `export_name` и `no_mangle`
&gt; очень мощные, но их легко использовать неправильно. Неверное использование
&gt; любого из этих атрибутов может вызвать неопределенное поведение;
&gt; Вам следует всегда предпочитать использование безопасных, высокоуровневых
&gt; атрибутов вокруг них, таких как атрибуты `interrupt` и `exception`
&gt; из `cortex-m-rt`.
&gt;
&gt; В особых случаях функций RAM нет безопасной абстракции в `cortex-m-rt`
&gt; v0.6.5 но создано [RFC] для добавления атрибута `ramfunc` в будущем релизе.

[RFC]: https://github.com/rust-embedded/cortex-m-rt/pull/100

В примере ниже показано как разместить высокоприоритетную задачу `bar` в ОЗУ.

``` rust
//! examples/ramfunc.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [bar])]
    fn init(c: init::Context) {
        c.spawn.bar().unwrap();
    }

    #[inline(never)]
    #[task]
    fn foo(_: foo::Context) {
        hprintln!(&quot;foo&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    // run this task from RAM
    #[inline(never)]
    #[link_section = &quot;.data.bar&quot;]
    #[task(priority = 2, spawn = [foo])]
    fn bar(c: bar::Context) {
        c.spawn.foo().unwrap();
    }

    extern &quot;C&quot; {
        fn UART0();

        // run the task dispatcher from RAM
        #[link_section = &quot;.data.UART1&quot;]
        fn UART1();
    }
};
</code></pre>
<p>Запуск этой программы произведет ожидаемый вывод.</p>
<pre><code class="language-console">$ cargo run --example ramfunc
foo```

Можно посмотреть на вывод `cargo-nm`, чтобы убедиться, что `bar` расположен в ОЗУ
(`0x2000_0000`), тогда как `foo` расположен во Flash (`0x0000_0000`).

``` console
$ cargo nm --example ramfunc --release | grep ' foo::'
00000162 t ramfunc::foo::h30e7789b08c08e19```

``` console
$ cargo nm --example ramfunc --release | grep ' bar::'
20000000 t ramfunc::bar::h9d6714fe5a3b0c89```

## `binds`

**ПРИМЕЧАНИЕ**: Требуется RTIC не ниже 0.4.2

Вы можете давать аппаратным задачам имена похожие на имена обычных задач.
Для этого нужно использовать аргумент `binds`: Вы называете функцию
по своему желанию и назначаете ей прерывание / исключение
через аргумент `binds`. `Spawn` и другие служебные типы будут размещены в модуле,
названном в соответствии с названием функции, а не прерывания / исключения.
Давайте посмотрим пример:

``` rust
//! examples/binds.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;
use panic_semihosting as _;

// `examples/interrupt.rs` rewritten to use `binds`
#[rtic::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        rtic::pend(Interrupt::UART0);

        hprintln!(&quot;init&quot;).unwrap();
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        hprintln!(&quot;idle&quot;).unwrap();

        rtic::pend(Interrupt::UART0);

        debug::exit(debug::EXIT_SUCCESS);

        loop {}
    }

    #[task(binds = UART0)]
    fn foo(_: foo::Context) {
        static mut TIMES: u32 = 0;

        *TIMES += 1;

        hprintln!(
            &quot;foo called {} time{}&quot;,
            *TIMES,
            if *TIMES &gt; 1 { &quot;s&quot; } else { &quot;&quot; }
        )
        .unwrap();
    }
};
</code></pre>
<pre><code class="language-console">$ cargo run --example binds
init
foo called 1 time
idle
foo called 2 times```</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Под-капотом"><a class="header" href="#Под-капотом">Под капотом</a></h1>
<p>В этом разделе описывабтся внутренности фркймворка на <em>высоком уровне</em>.
Низкоуровневые тонкости, такие как парсинг и кодогенерация производимые
процедурным макросом (<code>#[app]</code>) здесь объясняться не будут. Мы сосредоточимся
на анализе пользовательской спецификации и структурах данных, используемых
рантаймом.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ceiling-analysis"><a class="header" href="#ceiling-analysis">Ceiling analysis</a></h1>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-dispatcher"><a class="header" href="#task-dispatcher">Task dispatcher</a></h1>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timer-queue"><a class="header" href="#timer-queue">Timer queue</a></h1>
<p><strong>TODO</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
